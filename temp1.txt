Vận hành Node.js cho Server Side Rendering (SSR)

Trang web Airbnb đã được xây dựng phần frontend của nó dựa trên kĩ thuật SSR, Chúng tôi đã tìm hiểu làm thế nào cấu hình server tối ưu nhất để hỗ trợ cho việc này.

Ở Airbnb, Chúng tôi đã dành nhiều thời gian để chuyển tất cả code của phần Frontend thành một kiến trúc khác nơi mà toàn bộ các trang được viết dựa trên sự sắp xếp các components React và data được lấy từ các API của chúng tôi. Vai trò của Ruby on Rail trong việc tải 1 trang web đến brower giảm đi mỗi ngày. Trong thực tế , chúng tôi đã và đang triển khai việc chuyển đổi đến một service mới, service này sẽ DELIVER FULLY FORMED, server Nodejs sẽ render toàn bộ trang web. Service này sẽ render tất cả html cho tất cả các sản phẩm của Airbnb. Cơ chế rendering này khác so với hầu hết các service backend khác mà chúng ta đã biết nhờ không được viết bởi Ruby hay Java. Nhưng nó cũng khác so với các service NodeJS thuần I/O thông thường.

Khi bạn nghĩ về NodeJS, bạn sẽ nghĩ ngày đến một ứng dung bất đồng bộ có thể nhanh chóng xử lí hàng trăm hoặc hàng ngìn các connection đồng thời. Service của bạn lấy data từ DB, file System ,..vv và xử lí chúng nhanh chóng để đáp ứng nhanh chóng đến rất nhiều nhiều clients của nó. Có thể bạn đang xử lí một connection có thời gian dài như Websocket. Bạn vui vẻ và tự tin rằng mô hình đó là hoàn hảo cho tất cả các công việc

Cho đến khi bạn phải sử dụng SSR. Nó là một công việc thuần compute (tính toán) khác với thuần I/O là công việc chỉ nhập vào hay lấy dữ liệu ra, bạn có thể bắt đầu xử lí chúng một lúc nhưng không thể xử lí chúng cùng lúc. (Nghe loằng ngoằng nhỉ ...) NodeJs có khả năng xử lí một số lượng lớn các task I/O bất động bộ song song và cùng lúc nhưng điều này không xảy ra với các task compute. Cũng như số lượng công việc tính toán trong một request tăng lên so với công việc I/O thì độ trễ của việc response request đó cũng sẽ bị tăng lên bởi vì sự tranh chấp CPU

Ví dụ mình họa Promise.all([fn1, fn2]). Nếu fn1, fn2 là các fucntion xử lí task I/O bạn thực thi 2 task này cùng lúc và song song như thế này:


<img src="https://cdn-images-1.medium.com/max/1040/1*lThGroUdqu2A7VXGJReXYQ.png" />


Nhưng nếu trong trường hợp fn1, fn2 thực thi các công việc tính toán , thì chúng sẽ được thưc thi theo thứ tự như sau :

<img src="https://cdn-images-1.medium.com/max/1040/1*yeMtBsHLQrli2ieP5Hcfqg.png" />

một phép tính sẽ phải chờ cái khác kết thúc trước khi nó có thể chạy. Bởi vì chỉ có một thread thực thi duy nhất.


Đối với việc SSR điều này đến khi server tiến hành xử lí nhiều request đồng thời. Các request đồng thời khác sẽ được hoãn lại bởi các request khác đang được xử lí:

<img src="https://cdn-images-1.medium.com/max/1040/1*9_OEq81UNxVZkffgRJl6uQ.png"/>

Trong thực tế, các requests thường bao gồm nhiều giai đoạn bất đồng bộ khác nhau, kể cả khi chủ yếu là tính toán. Điều này thậm chí còn tồi tệ hơn cả việc thưc thi xen kẽ. Nếu nhưng request của chúng ta được xử lĩ bằng một chuỗi hành động như renderPromise().then(out => formatResponsePromise(out)).then(body => res.send(body)), chúng ta sẽ có một request xen kẽ như này

<img src="https://cdn-images-1.medium.com/max/1040/1*XnjCVYp-Zt20kBXLkZOQnA.png"/>

Trong trường hợp nào thì các request sẽ kết thúc trong thời gian dài gấp đôi. Vấn đề này trở nên nghiêm trọng hơn khi nhiều request đồng thời tăng lên.

Ngoài ra, một mục tiêu của SSR đó là có khả năng sử dụng cùng hoặc một vài code trên cả client và server. Điểm khác nhau giữa các môi trường này là client thì phục vụ duy nhất cho 1 user còn server thì phục vụ cho nhiều user. Công việc dễ dàng hoạt động trên client side giống như singletons hoặc trạng thái toàn cầu khác sẽ trả về bugs, thiếu, lỗi data và sự hỗn loạn theo các request đồng thời được load trên server

Tất cả những issue này sẽ trở thành 1 vấn đề với các request đồng thời. Mọi thứ sẽ thường chỉ làm việc với server có ít request đồng thời 1 lúc hoặc trong môi trường phát triển của bạn.

Điều này dẫn đến một tình huống đó là sự khác nhau từ một ví dụ của ứng dụng Node. Chúng tôi sử dụng JS cho thư viện của nó hỗ trợ và trình duyệt thay vì cho mô hình đồng thời của nó. Trong ứng này , mô hình bất đồng bộ đã trả giá cho một tí lợi ích của nó.


Bài học từ Hyoernova

Một dịch vụ rendering của chúng tôi, Hyperloop , sẽ trở thành dịch vụ cơ bản cái mà tất cả người của Airbnb website tương tác với nó. Độ tin cậy và perfomance 
rất quan trọng đối với trải nghiệm của người dùng. Vì vậy chúng tôi đã move đến việc chạy sản phẩm trên 1 dịch vụ mới. Chúng tôi đã kết hợp tất cả các bài học mà chúng tôi đã học từ service SSR của chúng tôi, Hypernova


Hypernova làm việc khác với dịch vụ mới của chúng tôi. Nó chỉ làm công việc render thuần túy. Nó được gọi từ một server monolith Rails và trả về Html cho Component đang yêu cầu. Trong nhiều trường hợp, một mảnh là toàn bộ content chính của page r, Rail chỉ cung cấp layout bao ngoài. Trong một só trường hợp kế thừa, các mảnh của trang có thể gắn với nhau sử dụng ERB (Hệ tài nguyên của doanh nghiệp). Tuy nhiên , trong cả 2 trường hợp , Hypernove không nạp, xử lí dữ liệu từ chính nó mà data được cung cấp bằng Rails


Điều này nói răng, Hyporloop và Hypernova có những điểm hoạt đông giống nhau cũng như việc tính toán đồng thời, và cũng như một service đang chạy trên production với lưu lượng truy cập đáng kể.

<img src="https://cdn-images-1.medium.com/max/1040/1*ttOAiNGuR2bHntz2WI-cEA.png"/>

Các request đến từ user đên với server Rail của chúng tôi, tại đây Rail có nhiệm vụ chuẩn bị data cho các props của các components sau đó Rail sẽ tạo một request với tất cả các props đó và tên của components lên Hypernova

Hypernova sẽ render components với props mà Rail vừa gửi lên để tạo ra HTML và trả về cho Rail, tất cả code HTML này sẽ được nhúng vào page templage và gửi toàn bộ về phía client


<img src="https://cdn-images-1.medium.com/max/1040/1*CO_ntlRx7YtWv0of7oGGfQ.png"/>


Hyper


 


